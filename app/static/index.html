<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Avia - Your Travel Assistant</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/chatbot.css">
</head>
<body>
    <div id="app">
        <!-- Header -->
        <header class="header">
            <div class="header-brand">
                <div class="header-logo">‚úàÔ∏è</div>
                <div>
                    <div class="header-title">Avia</div>
                    <div class="header-subtitle">Your In-Flight Travel Assistant</div>
                </div>
            </div>
            <div class="header-settings">
                <button class="settings-btn" @click="showSettings = !showSettings">
                    ‚öôÔ∏è <span>{{ seatNumber }}</span>
                </button>
            </div>
        </header>

        <!-- Chat Container -->
        <div class="chat-container">
            <!-- Messages Area -->
            <div class="messages-area" ref="messagesArea">
                <!-- Welcome Screen (shown when no messages) -->
                <div v-if="messages.length === 0" class="welcome-screen">
                    <div class="welcome-avatar">‚úàÔ∏è</div>
                    <h1 class="welcome-title">Hello! I'm Avia</h1>
                    <p class="welcome-subtitle">
                        Your personal travel assistant. Ask me anything about your destination, 
                        request in-flight services, or get travel tips in your preferred language.
                    </p>
                    <div class="quick-prompts">
                        <button class="quick-prompt" @click="sendQuickPrompt(quickPrompts.attractions)">
                            üèõÔ∏è {{ quickPrompts.attractions }}
                        </button>
                        <button class="quick-prompt" @click="sendQuickPrompt(quickPrompts.cuisine)">
                            üçú {{ quickPrompts.cuisine }}
                        </button>
                        <button class="quick-prompt" @click="sendQuickPrompt(quickPrompts.water)">
                            üíß {{ quickPrompts.water }}
                        </button>
                        <button class="quick-prompt" @click="sendQuickPrompt(quickPrompts.weather)">
                            üå§Ô∏è {{ quickPrompts.weather }}
                        </button>
                    </div>
                </div>

                <!-- Message List -->
                <template v-for="(msg, index) in messages" :key="index">
                    <div :class="['message', msg.role]">
                        <div class="message-avatar">
                            {{ msg.role === 'user' ? 'üë§' : '‚úàÔ∏è' }}
                        </div>
                        <div>
                            <div class="message-content" v-html="msg.html || msg.content"></div>
                            <div class="message-meta">
                                <span>{{ formatTime(msg.timestamp) }}</span>
                                <span v-if="msg.fromCache">‚ö° Cached</span>
                            </div>
                            <div v-if="msg.serviceAlert" class="service-badge">
                                ‚úÖ Crew notified
                            </div>
                        </div>
                    </div>
                </template>

                <!-- Typing Indicator -->
                <div v-if="isLoading" class="typing-indicator">
                    <div class="typing-avatar">‚úàÔ∏è</div>
                    <div class="typing-bubble">
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                    </div>
                </div>
            </div>

            <!-- Input Area -->
            <div class="input-area">
                <div class="input-context">
                    <div class="context-chip">
                        üåç
                        <input 
                            type="text" 
                            v-model="destination" 
                            placeholder="Destination"
                            style="width: 80px;"
                        >
                    </div>
                    <div class="context-chip">
                        üåê
                        <select v-model="language">
                            <option value="en">English</option>
                            <option value="es">Espa√±ol</option>
                            <option value="fr">Fran√ßais</option>
                            <option value="de">Deutsch</option>
                            <option value="hi">‡§π‡§ø‡§Ç‡§¶‡•Ä</option>
                            <option value="pt">Portugu√™s</option>
                            <option value="th">‡πÑ‡∏ó‡∏¢</option>
                        </select>
                    </div>
                </div>
                <div class="input-wrapper">
                    <div class="input-box">
                        <textarea 
                            ref="inputField"
                            v-model="inputText"
                            @keydown.enter.exact.prevent="sendMessage"
                            placeholder="Ask me anything..."
                            rows="1"
                            @input="autoResize"
                        ></textarea>
                        <button 
                            v-if="speechSupported"
                            class="mic-btn" 
                            :class="{ recording: isListening }"
                            @click="toggleSpeech"
                            :title="isListening ? 'Stop recording' : 'Voice input'"
                        >
                            {{ isListening ? '‚èπÔ∏è' : 'üé§' }}
                        </button>
                    </div>
                    <button 
                        class="send-btn" 
                        @click="sendMessage"
                        :disabled="!canSend"
                        title="Send message"
                    >
                        ‚û§
                    </button>
                </div>
            </div>
        </div>

        <!-- Settings Panel -->
        <div v-if="showSettings" class="backdrop" @click="showSettings = false"></div>
        <div class="settings-panel" :class="{ open: showSettings }">
            <div class="settings-header">
                <span class="settings-title">Settings</span>
                <button class="settings-close" @click="showSettings = false">‚úï</button>
            </div>
            <div class="settings-group">
                <div class="settings-label">Seat Number</div>
                <input class="settings-input" type="text" v-model="seatNumber" placeholder="e.g., 12A">
            </div>
            <div class="settings-group">
                <div class="settings-label">Destination</div>
                <input class="settings-input" type="text" v-model="destination" placeholder="e.g., Dubai">
            </div>
            <div class="settings-group">
                <div class="settings-label">Language</div>
                <select class="settings-input" v-model="language">
                    <option value="en">English</option>
                    <option value="es">Spanish</option>
                    <option value="fr">French</option>
                    <option value="de">German</option>
                    <option value="hi">Hindi</option>
                    <option value="pt">Portuguese</option>
                    <option value="th">Thai</option>
                </select>
            </div>
            <div class="settings-group" style="margin-top: 32px; padding-top: 16px; border-top: 1px solid var(--border);">
                <button class="settings-btn" style="width: 100%; justify-content: center;" @click="clearChat">
                    üóëÔ∏è Clear Conversation
                </button>
            </div>
        </div>

        <!-- Toast -->
        <div v-if="toast" :class="['toast', toast.type]">
            <span>{{ toast.icon }}</span>
            <span>{{ toast.message }}</span>
        </div>

        <!-- Service Request Confirmation -->
        <div v-if="showServiceConfirm" class="backdrop" @click="cancelServiceRequest"></div>
        <div class="service-confirm" :class="{ open: showServiceConfirm }">
            <div class="service-confirm-icon">üîî</div>
            <h3 class="service-confirm-title">Service Request Detected</h3>
            <p class="service-confirm-text">
                Would you like to notify the crew about your request?
            </p>
            <div class="service-confirm-details" v-if="pendingService">
                <strong>{{ pendingService.serviceType }}</strong>
            </div>
            <div class="service-confirm-actions">
                <button class="service-confirm-btn cancel" @click="cancelServiceRequest">
                    ‚úï Just Answer
                </button>
                <button class="service-confirm-btn confirm" @click="confirmServiceRequest">
                    ‚úì Notify Crew
                </button>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, computed, watch, nextTick, onMounted } = Vue;

        // Language codes for speech recognition
        const LANGUAGE_MAP = {
            'en': 'en-US',
            'es': 'es-ES', 
            'fr': 'fr-FR',
            'de': 'de-DE',
            'hi': 'hi-IN',
            'pt': 'pt-BR',
            'th': 'th-TH'
        };

        createApp({
            setup() {
                // State
                const messages = ref([]);
                const inputText = ref('');
                const isLoading = ref(false);
                const seatNumber = ref(localStorage.getItem('seatNumber') || '12A');
                const destination = ref(localStorage.getItem('destination') || 'Dubai');
                const language = ref(localStorage.getItem('language') || 'en');
                const showSettings = ref(false);
                const toast = ref(null);
                const messagesArea = ref(null);
                const inputField = ref(null);

                // Quick prompts (translated based on language)
                const quickPrompts = ref({
                    attractions: 'What are the top attractions?',
                    cuisine: 'What local food should I try?',
                    water: 'Can I get some water please?',
                    weather: "What's the weather like?"
                });

                // Speech recognition
                const speechSupported = ref(false);
                const isListening = ref(false);
                let recognition = null;

                // Service request confirmation
                const pendingService = ref(null);
                const showServiceConfirm = ref(false);

                // Computed
                const canSend = computed(() => {
                    return inputText.value.trim() && destination.value.trim() && !isLoading.value;
                });

                // Methods
                const formatTime = (timestamp) => {
                    if (!timestamp) return '';
                    const date = new Date(timestamp);
                    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                };

                const showToast = (message, type = 'success', icon = '‚úì') => {
                    toast.value = { message, type, icon };
                    setTimeout(() => { toast.value = null; }, 3000);
                };

                const scrollToBottom = async () => {
                    await nextTick();
                    if (messagesArea.value) {
                        messagesArea.value.scrollTop = messagesArea.value.scrollHeight;
                    }
                };

                const autoResize = (e) => {
                    const el = e.target;
                    el.style.height = 'auto';
                    el.style.height = Math.min(el.scrollHeight, 120) + 'px';
                };

                const sendMessage = async () => {
                    if (!canSend.value) return;

                    const query = inputText.value.trim();
                    inputText.value = '';
                    
                    // Reset textarea height
                    if (inputField.value) {
                        inputField.value.style.height = 'auto';
                    }

                    // Add user message
                    messages.value.push({
                        role: 'user',
                        content: query,
                        timestamp: new Date().toISOString()
                    });

                    scrollToBottom();
                    isLoading.value = true;

                    try {
                        const response = await fetch('/api/query', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                query,
                                destination: destination.value,
                                seatNumber: seatNumber.value,
                                language: language.value
                            })
                        });

                        const data = await response.json();
                        
                        // Check if service was detected
                        if (data.service_detected) {
                            // Store pending service request
                            pendingService.value = {
                                query,
                                serviceType: data.service_type,
                                priority: data.priority
                            };
                            showServiceConfirm.value = true;
                        } else {
                            // Parse markdown for regular response
                            const htmlContent = marked.parse(data.answer || data.response || '');

                            messages.value.push({
                                role: 'assistant',
                                content: data.answer || data.response,
                                html: htmlContent,
                                timestamp: data.timestamp || new Date().toISOString(),
                                fromCache: data.from_cache,
                                serviceAlert: data.service_alert_sent
                            });
                        }

                    } catch (error) {
                        console.error('Error:', error);
                        showToast('Failed to get response. Please try again.', 'error', '‚ùå');
                        
                        messages.value.push({
                            role: 'assistant',
                            content: 'Sorry, I encountered an error. Please try again.',
                            timestamp: new Date().toISOString()
                        });
                    }

                    isLoading.value = false;
                    scrollToBottom();
                };

                const sendQuickPrompt = (prompt) => {
                    inputText.value = prompt;
                    sendMessage();
                };

                const confirmServiceRequest = async () => {
                    if (!pendingService.value) return;

                    isLoading.value = true;
                    showServiceConfirm.value = false;

                    try {
                        const response = await fetch('/api/service-request', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                query: pendingService.value.query,
                                destination: destination.value,
                                seatNumber: seatNumber.value,
                                language: language.value
                            })
                        });

                        const data = await response.json();
                        const htmlContent = marked.parse(data.answer || '');

                        messages.value.push({
                            role: 'assistant',
                            content: data.answer,
                            html: htmlContent,
                            timestamp: data.timestamp || new Date().toISOString(),
                            serviceAlert: true
                        });

                        showToast('Crew has been notified!', 'success', '‚úÖ');
                    } catch (error) {
                        console.error('Error:', error);
                        showToast('Failed to send service request.', 'error', '‚ùå');
                    }

                    pendingService.value = null;
                    isLoading.value = false;
                    scrollToBottom();
                };

                const cancelServiceRequest = async () => {
                    if (!pendingService.value) return;

                    showServiceConfirm.value = false;
                    isLoading.value = true;

                    try {
                        // Send as regular query - add context to avoid re-triggering service detection
                        const response = await fetch('/api/query', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                query: 'Tell me about: ' + pendingService.value.query,
                                destination: destination.value,
                                seatNumber: seatNumber.value,
                                language: language.value
                            })
                        });

                        const data = await response.json();
                        
                        // Handle response even if service is re-detected
                        if (data.service_detected) {
                            // If still detected as service, try with explicit info request
                            const retryResponse = await fetch('/api/query', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    query: 'What information can you give me about ' + pendingService.value.query + '? I just want to know, not request it.',
                                    destination: destination.value,
                                    seatNumber: seatNumber.value,
                                    language: language.value
                                })
                            });
                            const retryData = await retryResponse.json();
                            if (retryData.answer) {
                                const htmlContent = marked.parse(retryData.answer);
                                messages.value.push({
                                    role: 'assistant',
                                    content: retryData.answer,
                                    html: htmlContent,
                                    timestamp: retryData.timestamp || new Date().toISOString(),
                                    fromCache: retryData.from_cache
                                });
                            }
                        } else {
                            const htmlContent = marked.parse(data.answer || data.response || '');
                            messages.value.push({
                                role: 'assistant',
                                content: data.answer || data.response,
                                html: htmlContent,
                                timestamp: data.timestamp || new Date().toISOString(),
                                fromCache: data.from_cache
                            });
                        }
                    } catch (error) {
                        console.error('Error:', error);
                        showToast('Failed to get response.', 'error', '‚ùå');
                    }

                    pendingService.value = null;
                    isLoading.value = false;
                    scrollToBottom();
                };

                const clearChat = async () => {
                    try {
                        await fetch(`/api/conversation/${seatNumber.value}`, { method: 'DELETE' });
                        messages.value = [];
                        showToast('Conversation cleared', 'success', 'üóëÔ∏è');
                        showSettings.value = false;
                    } catch (error) {
                        showToast('Failed to clear conversation', 'error', '‚ùå');
                    }
                };

                // Speech recognition
                const initSpeechRecognition = () => {
                    if ('SpeechRecognition' in window || 'webkitSpeechRecognition' in window) {
                        speechSupported.value = true;
                        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                        recognition = new SpeechRecognition();
                        recognition.continuous = true;
                        recognition.interimResults = true;

                        recognition.onresult = (event) => {
                            let transcript = '';
                            for (let i = event.resultIndex; i < event.results.length; i++) {
                                transcript += event.results[i][0].transcript;
                            }
                            inputText.value = transcript;
                        };

                        recognition.onend = () => {
                            isListening.value = false;
                        };

                        recognition.onerror = () => {
                            isListening.value = false;
                        };
                    }
                };

                const toggleSpeech = () => {
                    if (!recognition) return;

                    if (isListening.value) {
                        recognition.stop();
                        isListening.value = false;
                    } else {
                        recognition.lang = LANGUAGE_MAP[language.value] || 'en-US';
                        recognition.start();
                        isListening.value = true;
                    }
                };

                // Translate quick prompts to current language
                const translateQuickPrompts = async () => {
                    if (language.value === 'en') {
                        // Reset to English
                        quickPrompts.value = {
                            attractions: 'What are the top attractions?',
                            cuisine: 'What local food should I try?',
                            water: 'Can I get some water please?',
                            weather: "What's the weather like?"
                        };
                        return;
                    }

                    try {
                        const prompts = {
                            attractions: 'What are the top attractions?',
                            cuisine: 'What local food should I try?',
                            water: 'Can I get some water please?',
                            weather: "What's the weather like?"
                        };

                        // Translate each prompt
                        for (const [key, text] of Object.entries(prompts)) {
                            const response = await fetch('/api/translate', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ text, language: language.value })
                            });
                            const data = await response.json();
                            quickPrompts.value[key] = data.translated;
                        }
                    } catch (error) {
                        console.error('Failed to translate prompts:', error);
                    }
                };

                // Watchers - persist settings
                watch(seatNumber, (val) => localStorage.setItem('seatNumber', val));
                watch(destination, (val) => localStorage.setItem('destination', val));
                watch(language, (val) => {
                    localStorage.setItem('language', val);
                    translateQuickPrompts();  // Translate quick prompts when language changes
                });

                // Lifecycle
                onMounted(() => {
                    initSpeechRecognition();
                    translateQuickPrompts();  // Translate prompts on load
                    inputField.value?.focus();
                });

                return {
                    messages,
                    inputText,
                    isLoading,
                    seatNumber,
                    destination,
                    language,
                    showSettings,
                    toast,
                    messagesArea,
                    inputField,
                    speechSupported,
                    isListening,
                    canSend,
                    pendingService,
                    showServiceConfirm,
                    quickPrompts,
                    formatTime,
                    autoResize,
                    sendMessage,
                    sendQuickPrompt,
                    confirmServiceRequest,
                    cancelServiceRequest,
                    clearChat,
                    toggleSpeech
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
